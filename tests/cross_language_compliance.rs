//! Cross-Language Compliance Tests
//!
//! These tests load golden JSON fixtures generated by the official A2A Python SDK
//! (google/a2a-python) and verify the Rust SDK can:
//! 1. Deserialize them (accept spec-compliant input)
//! 2. Re-serialize them and get the same JSON back (produce spec-compliant output)
//!
//! The fixtures are generated by: tests/fixtures/generate_golden.py
//! They are NOT hand-written — they come directly from Python SDK's model_dump().
//!
//! If a test fails, it means the Rust SDK disagrees with the Python SDK on wire format.

use a2a_rs::types::*;
use serde_json::Value;
use std::path::PathBuf;

/// Load a golden JSON fixture file generated by the Python SDK.
fn load_fixture(name: &str) -> Value {
    let path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures")
        .join(format!("{name}.json"));
    let content = std::fs::read_to_string(&path)
        .unwrap_or_else(|e| panic!("Failed to read fixture {}: {e}", path.display()));
    serde_json::from_str(&content)
        .unwrap_or_else(|e| panic!("Failed to parse fixture {}: {e}", path.display()))
}

/// Deserialize golden JSON into type T, re-serialize, and compare.
/// Keys are compared as sorted JSON to handle key ordering differences.
fn assert_cross_lang_round_trip<T>(name: &str)
where
    T: serde::Serialize + serde::de::DeserializeOwned,
{
    let golden = load_fixture(name);

    // Step 1: Python SDK JSON → Rust type (can we deserialize it?)
    let rust_value: T = serde_json::from_value(golden.clone()).unwrap_or_else(|e| {
        panic!(
            "DESERIALIZATION FAILED for fixture '{name}':\n  Error: {e}\n  Python SDK JSON:\n{}\n",
            serde_json::to_string_pretty(&golden).unwrap()
        )
    });

    // Step 2: Rust type → JSON (does our output match Python's?)
    let rust_json = serde_json::to_value(&rust_value).unwrap();

    // Compare with normalized key order
    let golden_str = serde_json::to_string_pretty(&golden).unwrap();
    let rust_str = serde_json::to_string_pretty(&rust_json).unwrap();

    assert_eq!(
        rust_json, golden,
        "\nROUND-TRIP MISMATCH for fixture '{name}':\n\
         \n--- Python SDK (expected) ---\n{golden_str}\
         \n--- Rust SDK (actual) ---\n{rust_str}\n"
    );
}

/// Like assert_cross_lang_round_trip but only checks deserialization (not re-serialization).
/// Use this when Rust has extra default fields that Python omits.
fn assert_cross_lang_deserialize<T>(name: &str) -> T
where
    T: serde::Serialize + serde::de::DeserializeOwned + std::fmt::Debug,
{
    let golden = load_fixture(name);
    serde_json::from_value(golden.clone()).unwrap_or_else(|e| {
        panic!(
            "DESERIALIZATION FAILED for fixture '{name}':\n  Error: {e}\n  Python SDK JSON:\n{}\n",
            serde_json::to_string_pretty(&golden).unwrap()
        )
    })
}

// ============================================================================
// TaskState
// ============================================================================

#[test]
fn cross_lang_task_state_all_values() {
    let golden = load_fixture("task_state_all");
    let states: Vec<String> = serde_json::from_value(golden).unwrap();

    // Python SDK defines these exact string values for TaskState
    let expected = vec![
        "submitted",
        "working",
        "input-required",
        "completed",
        "canceled",
        "failed",
        "rejected",
        "auth-required",
        "unknown",
    ];
    assert_eq!(states, expected);

    // Verify each one deserializes to the correct Rust variant
    for state_str in &states {
        let json_str = format!("\"{state_str}\"");
        let result: Result<TaskState, _> = serde_json::from_str(&json_str);
        assert!(
            result.is_ok(),
            "Failed to deserialize TaskState '{state_str}' from Python SDK"
        );
    }

    // Verify Rust serialization matches Python for each
    let rust_states = vec![
        TaskState::Submitted,
        TaskState::Working,
        TaskState::InputRequired,
        TaskState::Completed,
        TaskState::Canceled,
        TaskState::Failed,
        TaskState::Rejected,
        TaskState::AuthRequired,
        TaskState::Unknown,
    ];
    for (rust_state, python_str) in rust_states.iter().zip(expected.iter()) {
        let serialized = serde_json::to_value(rust_state).unwrap();
        assert_eq!(
            serialized,
            serde_json::Value::String(python_str.to_string()),
            "TaskState::{rust_state:?} serializes to {:?}, Python SDK expects \"{python_str}\"",
            serialized
        );
    }
}

// ============================================================================
// Edge Case Fixtures (from generate_edge_cases.py)
// ============================================================================

// -- Message edge cases --

#[test]
fn cross_lang_message_mixed_parts() {
    assert_cross_lang_round_trip::<Message>("message_mixed_parts");
}

#[test]
fn cross_lang_message_empty_parts() {
    assert_cross_lang_round_trip::<Message>("message_empty_parts");
}

// -- Task state variants --

#[test]
fn cross_lang_task_state_completed() {
    assert_cross_lang_round_trip::<Task>("task_state_completed");
}

#[test]
fn cross_lang_task_state_failed() {
    assert_cross_lang_round_trip::<Task>("task_state_failed");
}

#[test]
fn cross_lang_task_state_canceled() {
    assert_cross_lang_round_trip::<Task>("task_state_canceled");
}

#[test]
fn cross_lang_task_state_rejected() {
    assert_cross_lang_round_trip::<Task>("task_state_rejected");
}

#[test]
fn cross_lang_task_state_input_required() {
    assert_cross_lang_round_trip::<Task>("task_state_input_required");
}

#[test]
fn cross_lang_task_state_auth_required() {
    assert_cross_lang_round_trip::<Task>("task_state_auth_required");
}

// -- Task collection edge cases --

#[test]
fn cross_lang_task_empty_collections() {
    assert_cross_lang_round_trip::<Task>("task_empty_collections");
}

#[test]
fn cross_lang_task_multiple_artifacts() {
    assert_cross_lang_round_trip::<Task>("task_multiple_artifacts");
}

// -- Artifact edge cases --

#[test]
fn cross_lang_artifact_file_parts() {
    assert_cross_lang_round_trip::<Artifact>("artifact_file_parts");
}

// -- Streaming event edge cases --

#[test]
fn cross_lang_status_update_with_message() {
    assert_cross_lang_round_trip::<TaskStatusUpdateEvent>("status_update_with_message");
}

#[test]
fn cross_lang_artifact_update_append() {
    assert_cross_lang_round_trip::<TaskArtifactUpdateEvent>("artifact_update_append");
}

// -- SecurityScheme edge cases --

#[test]
fn cross_lang_security_apikey_query() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_apikey_query");
}

#[test]
fn cross_lang_security_apikey_cookie() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_apikey_cookie");
}

#[test]
fn cross_lang_security_http_basic() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_http_basic");
}

#[test]
fn cross_lang_security_http_bearer_no_format() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_http_bearer_no_format");
}

#[test]
fn cross_lang_security_oauth2_client_creds() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_oauth2_client_creds");
}

#[test]
fn cross_lang_security_oauth2_multi_flow() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_oauth2_multi_flow");
}

#[test]
fn cross_lang_security_openid_with_desc() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_openid_with_desc");
}

#[test]
fn cross_lang_security_mtls_with_desc() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_mtls_with_desc");
}

// -- AgentCard variants (deserialize-only, Rust may add defaults) --

#[test]
fn cross_lang_agent_card_with_security() {
    let card: AgentCard = assert_cross_lang_deserialize("agent_card_with_security");
    assert_eq!(card.name, "Secure Agent");
    assert!(card.security_schemes.is_some());
}

#[test]
fn cross_lang_agent_card_with_extensions() {
    let card: AgentCard = assert_cross_lang_deserialize("agent_card_with_extensions");
    assert_eq!(card.name, "Extended Agent");
}

#[test]
fn cross_lang_agent_card_with_signatures() {
    let card: AgentCard = assert_cross_lang_deserialize("agent_card_with_signatures");
    assert_eq!(card.name, "Signed Agent");
}

// -- PushNotificationConfig --

#[test]
fn cross_lang_push_config_full() {
    assert_cross_lang_round_trip::<PushNotificationConfig>("push_config_full");
}

// -- SendMessageParams (full) --

#[test]
fn cross_lang_send_params_full() {
    assert_cross_lang_round_trip::<SendMessageParams>("send_params_full");
}

// -- Complex data part --

#[test]
fn cross_lang_part_data_complex() {
    assert_cross_lang_round_trip::<Part>("part_data_complex");
}
// ============================================================================
// Part variants
// ============================================================================

#[test]
fn cross_lang_part_text() {
    assert_cross_lang_round_trip::<Part>("part_text");
}

#[test]
fn cross_lang_part_text_with_metadata() {
    assert_cross_lang_round_trip::<Part>("part_text_with_metadata");
}

#[test]
fn cross_lang_part_file_bytes() {
    assert_cross_lang_round_trip::<Part>("part_file_bytes");
}

#[test]
fn cross_lang_part_file_uri() {
    assert_cross_lang_round_trip::<Part>("part_file_uri");
}

#[test]
fn cross_lang_part_data() {
    assert_cross_lang_round_trip::<Part>("part_data");
}

#[test]
fn cross_lang_part_data_with_metadata() {
    assert_cross_lang_round_trip::<Part>("part_data_with_metadata");
}

// ============================================================================
// Message
// ============================================================================

#[test]
fn cross_lang_message_minimal() {
    assert_cross_lang_round_trip::<Message>("message_minimal");
}

#[test]
fn cross_lang_message_full() {
    assert_cross_lang_round_trip::<Message>("message_full");
}

// ============================================================================
// TaskStatus
// ============================================================================

#[test]
fn cross_lang_task_status_minimal() {
    assert_cross_lang_round_trip::<TaskStatus>("task_status_minimal");
}

#[test]
fn cross_lang_task_status_full() {
    assert_cross_lang_round_trip::<TaskStatus>("task_status_full");
}

// ============================================================================
// Task
// ============================================================================

#[test]
fn cross_lang_task_minimal() {
    assert_cross_lang_round_trip::<Task>("task_minimal");
}

#[test]
fn cross_lang_task_full() {
    assert_cross_lang_round_trip::<Task>("task_full");
}

// ============================================================================
// Artifact
// ============================================================================

#[test]
fn cross_lang_artifact() {
    assert_cross_lang_round_trip::<Artifact>("artifact");
}

// ============================================================================
// Streaming Events
// ============================================================================

#[test]
fn cross_lang_task_status_update_event() {
    assert_cross_lang_round_trip::<TaskStatusUpdateEvent>("task_status_update_event");
}

#[test]
fn cross_lang_task_status_update_event_final() {
    assert_cross_lang_round_trip::<TaskStatusUpdateEvent>("task_status_update_event_final");
}

#[test]
fn cross_lang_task_artifact_update_event() {
    assert_cross_lang_round_trip::<TaskArtifactUpdateEvent>("task_artifact_update_event");
}

// ============================================================================
// StreamResponse (streaming events should also parse as StreamResponse)
// ============================================================================

#[test]
fn cross_lang_stream_response_status_update() {
    assert_cross_lang_round_trip::<StreamResponse>("task_status_update_event");
}

#[test]
fn cross_lang_stream_response_artifact_update() {
    assert_cross_lang_round_trip::<StreamResponse>("task_artifact_update_event");
}

#[test]
fn cross_lang_stream_response_task() {
    assert_cross_lang_round_trip::<StreamResponse>("task_minimal");
}

#[test]
fn cross_lang_stream_response_message() {
    assert_cross_lang_round_trip::<StreamResponse>("message_minimal");
}

// ============================================================================
// SendMessageResponse (task and message should parse)
// ============================================================================

#[test]
fn cross_lang_send_message_response_as_task() {
    assert_cross_lang_round_trip::<SendMessageResponse>("task_minimal");
}

#[test]
fn cross_lang_send_message_response_as_message() {
    assert_cross_lang_round_trip::<SendMessageResponse>("message_minimal");
}

// ============================================================================
// SecurityScheme variants
// ============================================================================

#[test]
fn cross_lang_security_scheme_apikey() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_scheme_apikey");
}

#[test]
fn cross_lang_security_scheme_http() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_scheme_http");
}

#[test]
fn cross_lang_security_scheme_oauth2() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_scheme_oauth2");
}

#[test]
fn cross_lang_security_scheme_openid() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_scheme_openid");
}

#[test]
fn cross_lang_security_scheme_mtls() {
    assert_cross_lang_round_trip::<SecurityScheme>("security_scheme_mtls");
}

// ============================================================================
// AgentInterface
// ============================================================================

#[test]
fn cross_lang_agent_interface() {
    assert_cross_lang_round_trip::<AgentInterface>("agent_interface");
}

#[test]
fn cross_lang_agent_interface_with_version() {
    assert_cross_lang_round_trip::<AgentInterface>("agent_interface_with_version");
}

// ============================================================================
// AgentCapabilities
// ============================================================================

#[test]
fn cross_lang_agent_capabilities_empty() {
    assert_cross_lang_round_trip::<AgentCapabilities>("agent_capabilities_empty");
}

#[test]
fn cross_lang_agent_capabilities_full() {
    assert_cross_lang_round_trip::<AgentCapabilities>("agent_capabilities_full");
}

// ============================================================================
// AgentSkill
// ============================================================================

#[test]
fn cross_lang_agent_skill() {
    assert_cross_lang_round_trip::<AgentSkill>("agent_skill");
}

// ============================================================================
// AgentProvider
// ============================================================================

#[test]
fn cross_lang_agent_provider() {
    assert_cross_lang_round_trip::<AgentProvider>("agent_provider");
}

// ============================================================================
// PushNotificationConfig
// ============================================================================

#[test]
fn cross_lang_push_notification_config() {
    assert_cross_lang_round_trip::<PushNotificationConfig>("push_notification_config");
}

// ============================================================================
// TaskPushNotificationConfig
// ============================================================================

#[test]
fn cross_lang_task_push_notification_config() {
    assert_cross_lang_round_trip::<TaskPushNotificationConfig>("task_push_notification_config");
}

// ============================================================================
// SendMessageParams
// ============================================================================

#[test]
fn cross_lang_send_message_params() {
    assert_cross_lang_round_trip::<SendMessageParams>("send_message_params");
}

// ============================================================================
// AgentCard — deserialize only (Rust may add default fields Python omits)
// ============================================================================

#[test]
fn cross_lang_agent_card_minimal() {
    // AgentCard may have extra default fields in Rust that Python omits,
    // so we test deserialization and verify key fields match
    let card: AgentCard = assert_cross_lang_deserialize("agent_card_minimal");
    assert_eq!(card.name, "Test Agent");
    assert_eq!(card.description, "A test agent");
    assert_eq!(card.version, "1.0.0");
    assert_eq!(card.url, "https://agent.example.com");
    assert_eq!(card.default_input_modes, vec!["text/plain"]);
    assert_eq!(card.default_output_modes, vec!["text/plain"]);
    assert_eq!(card.skills.len(), 1);
    assert_eq!(card.skills[0].id, "echo");

    // Verify round-trip: Rust serialization should contain all Python fields
    let rust_json = serde_json::to_value(&card).unwrap();
    let golden = load_fixture("agent_card_minimal");

    // Every key in the Python output must exist in the Rust output
    if let (Some(golden_obj), Some(rust_obj)) = (golden.as_object(), rust_json.as_object()) {
        for (key, python_val) in golden_obj {
            let rust_val = rust_obj.get(key);
            assert!(
                rust_val.is_some(),
                "Python SDK outputs field '{key}' but Rust SDK omits it"
            );
            assert_eq!(
                rust_val.unwrap(),
                python_val,
                "Field '{key}' differs between Python and Rust SDK"
            );
        }
    }
}
